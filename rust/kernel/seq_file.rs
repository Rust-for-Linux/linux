// SPDX-License-Identifier: GPL-2.0

//! Trait for defining `seq_file`s.
//!
//! This module allows Rust devices to implement [`struct seq_operations`] and
//! and create a file under `/proc` based on that implementation.
//!
//! C header: [`include/linux/seq_file.h`](../../../include/linux/seq_file.h)
//!
//! Reference: <https://www.kernel.org/doc/html/latest/filesystems/seq_file.html>

// Currently this module is only usable through proc_fs.
#![cfg(CONFIG_PROC_FS)]

use core::{
    iter::{Iterator, Peekable},
    marker::PhantomData,
    mem,
    ops::{Deref, DerefMut},
    ptr,
};

use crate::{bindings, c_str, c_types, str::CStr, types::PointerWrapper, Result};

/// Rust equivalent of the [`seq_operations`] interface on the C side.
///
/// # Example
///
/// ```rust,no_run
/// #![feature(allocator_api)]
///
/// use core::iter::Peekable;
/// use kernel::{Error, Result, seq_file};
///
/// struct Data(&'static [String]);
///
/// impl seq_file::SeqOperations for Data {
///     type Item = &'static String;
///     type Iterator = core::slice::Iter<'static, String>;
///     type DataWrapper = Box<Self>;
///     type IteratorWrapper = Box<Peekable<Self::Iterator>>;
///
///     fn start(&self) -> Result<Self::IteratorWrapper> {
///         let iter = self.0.iter();
///         Box::try_new(iter.peekable()).map_err(|_| Error::ENOMEM)
///     }
///
///     fn display(item: &Self::Item) -> &str {
///         &item[..]
///     }
/// }
/// ```
///
/// [`seq_operations`]: ../../../include/linux/seq_file.h
pub trait SeqOperations {
    /// Type produced on each iteration.
    type Item;

    /// Type created when the seq file is opened.
    type Iterator: Iterator<Item = Self::Item>;

    /// Wrapper used to store a pointer to `Self` on the C side.
    type DataWrapper: PointerWrapper + Deref<Target = Self>;

    /// Wrapper used to store a pointer to the iterator on the C side.
    type IteratorWrapper: PointerWrapper + DerefMut<Target = Peekable<Self::Iterator>>;

    /// Called once each time the `seq_file` is opened.
    fn start(&self) -> Result<Self::IteratorWrapper>;

    /// How the item will be displayed to the reader.
    fn display(item: &Self::Item) -> &str;
}

extern "C" fn stop_callback<T: SeqOperations>(
    _m: *mut bindings::seq_file,
    v: *mut c_types::c_void,
) {
    if !v.is_null() {
        // SAFETY: `v` was created by a previous call to `next_callback` or
        // `start_callback` and both functions return either a null pointer
        // or pointer generated by `T::IteratorWrapper::into_pointer`.
        drop(unsafe { T::IteratorWrapper::from_pointer(v) })
    }
}

extern "C" fn next_callback<T: SeqOperations>(
    _m: *mut bindings::seq_file,
    v: *mut c_types::c_void,
    pos: *mut bindings::loff_t,
) -> *mut c_types::c_void {
    if v.is_null() {
        return ptr::null_mut();
    }

    // SAFETY: `v` was created by a previous call to `next_callback` or
    // `start_callback` and both functions return either a null pointer
    // or pointer generated by `T::IteratorWrapper::into_pointer`.
    // We already checked for he null pointer case above.
    let mut iterator = unsafe { T::IteratorWrapper::from_pointer(v) };

    // SAFETY: The caller guarantees tha `pos` is a valid pointer to an
    // `loff_t` and expects this function to mutate the value.
    unsafe {
        *pos += 1;
    }

    if iterator.next().is_none() {
        return ptr::null_mut();
    }

    match iterator.peek() {
        Some(_next) => T::IteratorWrapper::into_pointer(iterator) as *mut _,
        None => ptr::null_mut(),
    }
}

extern "C" fn show_callback<T: SeqOperations>(
    m: *mut bindings::seq_file,
    v: *mut c_types::c_void,
) -> c_types::c_int {
    const FORMAT: &CStr = c_str!("%.*s");
    if v.is_null() {
        return 0;
    }
    // SAFETY: `v` was created by a previous call to `next_callback` or
    // `start_callback` and both functions return either a null pointer
    // or pointer generated by `T::IteratorWrapper::into_pointer`. We
    // checked for null pointers above. The iterator is forgotten below
    // so the pointer on the C side stays valid.
    let mut iterator = unsafe { T::IteratorWrapper::from_pointer(v) };
    if let Some(item) = iterator.peek() {
        let s = T::display(item);
        // SAFETY: Calling a C function. `FORMAT` is null terminated because
        // it comes from a `CStr`. `s` does not need to be null terminated
        // because we are only printing the first `s.len()` bytes.
        unsafe {
            bindings::seq_printf(
                m,
                FORMAT.as_char_ptr(),
                s.len(),
                s.as_ptr() as *const u8 as *const c_types::c_char,
            );
        }
    }
    // Need to forget the iterator because the C side is still using a
    // reference to it.
    mem::forget(iterator);
    0
}

extern "C" fn start_callback<T: SeqOperations>(
    m: *mut bindings::seq_file,
    pos: *mut bindings::loff_t,
) -> *mut c_types::c_void {
    // SAFETY: This function will be called by opening a proc file generated
    // from `proc_create_seq_private` on the C side with data created via
    // `T::DataWrapper::into_pointer`. We don't move the data in the wrapper
    // so the pointer will remain valid for later calls.
    let data_wrapper = unsafe { T::DataWrapper::from_pointer((*m).private) };
    let iterator = data_wrapper.start().ok();
    // Data is still used in the `proc_dir_entry`.
    mem::forget(data_wrapper);
    // SAFETY: The caller guarantees that `pos` points to a valid `loff_t`.
    let pos = unsafe { *pos };
    match iterator {
        Some(mut wrapper) => {
            for _ in 0..pos {
                if wrapper.next().is_none() {
                    return ptr::null_mut();
                }
            }
            match wrapper.peek() {
                Some(_next) => T::IteratorWrapper::into_pointer(wrapper) as *mut _,
                None => ptr::null_mut(),
            }
        }
        None => ptr::null_mut(),
    }
}

pub(crate) struct SeqFileOperationsVTable<T>(PhantomData<T>);

impl<T: SeqOperations> SeqFileOperationsVTable<T> {
    const SEQ_VTABLE: bindings::seq_operations = bindings::seq_operations {
        start: Some(start_callback::<T>),
        stop: Some(stop_callback::<T>),
        next: Some(next_callback::<T>),
        show: Some(show_callback::<T>),
    };

    // TODOABK: safety
    pub(crate) const unsafe fn seq_build() -> &'static bindings::seq_operations {
        &Self::SEQ_VTABLE
    }

    extern "C" fn open_callback(
        inode: *mut bindings::inode,
        file: *mut bindings::file,
    ) -> c_types::c_int {
        // TODOABK: docs
        unsafe {
            bindings::seq_open_private(
                file,
                &Self::SEQ_VTABLE as *const _ as *mut bindings::seq_operations,
                // TODOABK: how to convert safely?
                mem::size_of::<T::DataWrapper>() as i32,
            )
        }
    }

    const VTABLE: bindings::file_operations = bindings::file_operations {
        open: Some(Self::open_callback),
        release: Some(bindings::seq_release_private),
        read: Some(bindings::seq_read),
        llseek: Some(bindings::seq_lseek),

        check_flags: None,
        compat_ioctl: None,
        copy_file_range: None,
        fallocate: None,
        fadvise: None,
        fasync: None,
        flock: None,
        flush: None,
        fsync: None,
        get_unmapped_area: None,
        iterate: None,
        iterate_shared: None,
        iopoll: None,
        lock: None,
        mmap: None,
        mmap_supported_flags: 0,
        owner: ptr::null_mut(),
        poll: None,
        read_iter: None,
        remap_file_range: None,
        sendpage: None,
        setlease: None,
        show_fdinfo: None,
        splice_read: None,
        splice_write: None,
        unlocked_ioctl: None,
        write: None,
        write_iter: None,
    };

    // TODOABK: safety
    pub(crate) const unsafe fn build() -> &'static bindings::file_operations {
        &Self::VTABLE
    }
}
